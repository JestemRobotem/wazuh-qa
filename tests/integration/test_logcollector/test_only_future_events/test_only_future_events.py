'''
copyright: Copyright (C) 2015-2022, Wazuh Inc.

           Created by Wazuh, Inc. <info@wazuh.com>.

           This program is free software; you can redistribute it and/or modify it under the terms of GPLv2

type: integration

brief: The 'wazuh-logcollector' daemon monitors configured files and commands for new log messages.
       Specifically, these tests will check if the 'only-future-events' option of the logcollector
       works properly. Log data collection is the real-time process of making sense out of
       the records generated by servers or devices. This component can receive logs through
       text files or Windows event logs. It can also directly receive logs via remote syslog
       which is useful for firewalls and other such devices.

components:
    - logcollector

suite: only_future_events

targets:
    - agent
    - manager

daemons:
    - wazuh-logcollector

os_platform:
    - linux
    - macos
    - solaris

os_version:
    - Arch Linux
    - Amazon Linux 2
    - Amazon Linux 1
    - CentOS 8
    - CentOS 7
    - Debian Buster
    - Red Hat 8
    - Solaris 10
    - Solaris 11
    - macOS Catalina
    - macOS Server
    - Ubuntu Focal
    - Ubuntu Bionic

references:
    - https://documentation.wazuh.com/current/user-manual/capabilities/log-data-collection/index.html
    - https://documentation.wazuh.com/current/user-manual/reference/ossec-conf/localfile.html#only-future-events

tags:
    - logcollector_only_future_events
'''
import os
import tempfile
import sys

import pytest
import wazuh_testing.logcollector as logcollector
from wazuh_testing import global_parameters
from wazuh_testing.tools import monitoring, file
from wazuh_testing.tools.configuration import load_wazuh_configurations
from wazuh_testing.tools.monitoring import LOG_COLLECTOR_DETECTOR_PREFIX, WINDOWS_AGENT_DETECTOR_PREFIX
from wazuh_testing.tools.services import control_service


if sys.platform == 'win32':
    prefix = monitoring.WINDOWS_AGENT_DETECTOR_PREFIX
else:
    prefix = monitoring.LOG_COLLECTOR_DETECTOR_PREFIX

# Marks
pytestmark = [pytest.mark.tier(level=0)]

# Configuration
DAEMON_NAME = "wazuh-logcollector"
test_data_path = os.path.join(os.path.dirname(os.path.realpath(__file__)), 'data')
configurations_path = os.path.join(test_data_path, 'wazuh_only_future_events_conf.yaml')
temp_dir = tempfile.gettempdir()
log_test_path = os.path.join(temp_dir, 'wazuh-testing', 'test.log')
current_line = 0

local_internal_options = {'logcollector.vcheck_files': '5', 'logcollector.debug': '2', 'windows.debug': 2}

parameters = [
    {'LOG_FORMAT': 'syslog', 'LOCATION': log_test_path, 'ONLY_FUTURE_EVENTS': 'no', 'MAX_SIZE': '10MB'},
    {'LOG_FORMAT': 'syslog', 'LOCATION': log_test_path, 'ONLY_FUTURE_EVENTS': 'yes', 'MAX_SIZE': '10MB'}
]
metadata = [
    {'log_format': 'syslog', 'location': log_test_path, 'only_future_events': 'no',
     'log_line': "Jan  1 00:00:00 localhost test[0]: line="},
    {'log_format': 'syslog', 'location': log_test_path, 'only_future_events': 'yes',
     'log_line': "Jan  1 00:00:00 localhost test[0]: line="}
]

log_line = metadata[0]['log_line']

file_structure = [
    {
        'folder_path': os.path.join(temp_dir, 'wazuh-testing'),
        'filename': ['test.log'],
        'content': log_line,
        'size_kib': 10240
    }
]

configurations = load_wazuh_configurations(configurations_path, __name__, params=parameters, metadata=metadata)
configuration_ids = [f"rotate_{x['location']}_in_{x['log_format']}_format" for x in metadata]


# Fixtures
@pytest.fixture(scope="module", params=configurations, ids=configuration_ids)
def get_configuration(request):
    """Get configurations from the module."""
    return request.param


@pytest.fixture(scope="module")
def get_local_internal_options():
    """Get internal configuration."""
    return local_internal_options


@pytest.fixture(scope="module")
def get_files_list():
    """Get file list to create from the module."""
    return file_structure


def test_only_future_events(configure_local_internal_options_module, get_configuration, file_monitoring,
                            configure_environment, get_files_list, create_file_structure_module, restart_logcollector):
    '''
    description: Check if the 'only-future-events' option is used properly by the 'wazuh-logcollector' when
                 monitoring a log file. This option allows reading new log content since the logcollector
                 was stopped. For this purpose, the test will create a testing log file and configure a
                 'localfile' section to monitor it. Once the logcollector is started, it will verify that
                 the log file is monitored, add data to it, and verify that the data addition is detected.
                 Then, the test will stop the 'wazuh-logcollector' daemon, and while it is stopped, add more
                 data to the log file. After this, it will check if the addition event has been detected or not
                 (depending on the value of the 'only-future-events' tag). Finally, the test will perform one
                 aditional verification by adding data one more time to the log file and verifying that event
                 indicating the data addition is detected.

    wazuh_min_version: 4.2.0

    tier: 0

    parameters:
        - get_local_internal_options:
            type: fixture
            brief: Get local internal options from the module.
        - configure_local_internal_options:
            type: fixture
            brief: Configure the Wazuh local internal options.
        - get_configuration:
            type: fixture
            brief: Get configurations from the module.
        - configure_environment:
            type: fixture
            brief: Configure a custom environment for testing.
        - get_files_list:
            type: fixture
            brief: Get file list to create from the module.
        - create_file_structure_module:
            type: fixture
            brief: Create the specified file tree structure.
        - restart_logcollector:
            type: fixture
            brief: Clear the 'ossec.log' file and start a new monitor.

    assertions:
        - Verify that the logcollector starts monitoring the log file.
        - Verify that the logcollector detects data addition on a monitored log file.
        - Verify that the logcollector detects the logs messages generated while it stopped
          when it is started, and the 'only-future-events' option is disabled.
        - Verify that the logcollector ignores the logs messages generated while it stopped
          when it is started, and the 'only-future-events' option is enabled.
        - Verify that the log collector continues detecting new logs messages when it is started.

    input_description: A configuration template (test_only_future_events) is contained in an external YAML file
                       (wazuh_only_future_events_conf.yaml). That template is combined with two test cases defined
                       in the module. Those include configuration settings for the 'wazuh-logcollector' daemon.

    expected_output:
        - r'Analyzing file.*'
        - r'Reading syslog message.*'

    tags:
        - logs
    '''
    config = get_configuration['metadata']
    global current_line

    # Ensure that the file is being analyzed
    message = f"Analyzing file: '{log_test_path}'."
    callback_message = monitoring.make_callback(pattern=message, prefix=prefix, escape=True)
    log_monitor.start(timeout=global_parameters.default_timeout,
                      error_message=logcollector.GENERIC_CALLBACK_ERROR_COMMAND_MONITORING,
                      callback=callback_message)

    # Add one KiB of data to log
    current_line = logcollector.add_log_data(log_path=config['location'], log_line_message=config['log_line'],
                                             size_kib=1, line_start=current_line + 1, print_line_num=True)

    message = f"DEBUG: Reading syslog message: '{config['log_line']}{current_line}'"
    callback_message = monitoring.make_callback(pattern=message, prefix=prefix, escape=True)
    log_monitor.start(timeout=global_parameters.default_timeout,
                      error_message=logcollector.GENERIC_CALLBACK_ERROR_COMMAND_MONITORING,
                      callback=callback_message)

    control_service('stop', daemon=DAEMON_NAME)

    # Add another KiB of data to log while logcollector is stopped
    first_line = current_line + 1
    current_line = logcollector.add_log_data(log_path=config['location'], log_line_message=config['log_line'],
                                             size_kib=1, line_start=first_line, print_line_num=True)

    control_service('start', daemon=DAEMON_NAME)

    if config['only_future_events'] == 'no':
        # Logcollector should detect the first line written while it was stopped
        # Check first line
        message = f"DEBUG: Reading syslog message: '{config['log_line']}{first_line}'"
        callback_message = monitoring.make_callback(pattern=message, prefix=prefix, escape=True)
        log_monitor.start(timeout=global_parameters.default_timeout,
                          error_message=logcollector.GENERIC_CALLBACK_ERROR_COMMAND_MONITORING,
                          callback=callback_message)
        # Check last line
        message = f"DEBUG: Reading syslog message: '{config['log_line']}{current_line}'"
        callback_message = monitoring.make_callback(pattern=message, prefix=prefix, escape=True)
        log_monitor.start(timeout=global_parameters.default_timeout,
                          error_message=logcollector.GENERIC_CALLBACK_ERROR_COMMAND_MONITORING,
                          callback=callback_message)
    else:
        # Logcollector should NOT detect the log lines written while it was stopped
        with pytest.raises(TimeoutError):
            # Check first line
            message = f"DEBUG: Reading syslog message: '{config['log_line']}{first_line}'"
            callback_message = monitoring.make_callback(pattern=message, prefix=prefix,
                                                        escape=True)
            log_monitor.start(timeout=global_parameters.default_timeout,
                              error_message=logcollector.GENERIC_CALLBACK_ERROR_COMMAND_MONITORING,
                              callback=callback_message)
            # Check last line
            message = f"DEBUG: Reading syslog message: '{config['log_line']}{current_line}'"
            callback_message = monitoring.make_callback(pattern=message, prefix=prefix,
                                                        escape=True)
            log_monitor.start(timeout=global_parameters.default_timeout,
                              error_message=logcollector.GENERIC_CALLBACK_ERROR_COMMAND_MONITORING,
                              callback=callback_message)

    # Add another KiB of data to log (additional check)
    current_line = logcollector.add_log_data(log_path=config['location'], log_line_message=config['log_line'],
                                             size_kib=1, line_start=current_line + 1, print_line_num=True)

    message = f"DEBUG: Reading syslog message: '{config['log_line']}{current_line}'"
    callback_message = monitoring.make_callback(pattern=message, prefix=prefix, escape=True)
    log_monitor.start(timeout=global_parameters.default_timeout,
                      error_message=logcollector.GENERIC_CALLBACK_ERROR_COMMAND_MONITORING,
                      callback=callback_message)
