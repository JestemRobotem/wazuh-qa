'''
copyright: Copyright (C) 2015-2022, Wazuh Inc.

           Created by Wazuh, Inc. <info@wazuh.com>.

           This program is free software; you can redistribute it and/or modify it under the terms of GPLv2

type: integration

brief: The 'wazuh-logcollector' daemon monitors configured files and commands for new log messages.
       Specifically, these tests will check if the 'only-future-events' option of the logcollector
       works properly. Log data collection is the real-time process of making sense out of
       the records generated by servers or devices. This component can receive logs through
       text files or Windows event logs. It can also directly receive logs via remote syslog
       which is useful for firewalls and other such devices.

components:
    - logcollector

suite: only_future_events

targets:
    - agent
    - manager

daemons:
    - wazuh-logcollector

os_platform:
    - linux
    - macos
    - solaris

os_version:
    - Arch Linux
    - Amazon Linux 2
    - Amazon Linux 1
    - CentOS 8
    - CentOS 7
    - Debian Buster
    - Red Hat 8
    - Solaris 10
    - Solaris 11
    - macOS Catalina
    - macOS Server
    - Ubuntu Focal
    - Ubuntu Bionic

references:
    - https://documentation.wazuh.com/current/user-manual/capabilities/log-data-collection/index.html
    - https://documentation.wazuh.com/current/user-manual/reference/ossec-conf/localfile.html#only-future-events

tags:
    - logcollector_only_future_events
'''
import os
import tempfile
import sys

import pytest
import wazuh_testing.logcollector as logcollector
from wazuh_testing import global_parameters
from wazuh_testing.tools.services import control_service
from wazuh_testing.modules.logcollector import LOG_COLLECTOR_PREFIX, WINDOWS_AGENT_PREFIX, \
                                               GENERIC_CALLBACK_ERROR_COMMAND_MONITORING
from wazuh_testing.tools.configuration import load_configuration_template, get_test_cases_data
from wazuh_testing.modules.logcollector import event_monitor as evm


# Marks
pytestmark = [pytest.mark.tier(level=0)]

prefix = LOG_COLLECTOR_PREFIX

# Reference paths
TEST_DATA_PATH = os.path.join(os.path.dirname(os.path.realpath(__file__)), 'data')
CONFIGURATIONS_PATH = os.path.join(TEST_DATA_PATH, 'configuration_template')
TEST_CASES_PATH = os.path.join(TEST_DATA_PATH, 'test_cases')

# ------------------------------------------------ TEST_ACCEPTED_VALUES ------------------------------------------------
# Configuration and cases data
t1_configurations_path = os.path.join(CONFIGURATIONS_PATH, 'configuration_only_future_events.yaml')
t1_cases_path = os.path.join(TEST_CASES_PATH, 'cases_only_future_events.yaml')

temp_dir = tempfile.gettempdir()
log_test_path = os.path.join(temp_dir, 'wazuh-testing', 'test.log')
LOG_LINE = 'Jan  1 00:00:00 localhost test[0]: line='

# Accepted values test configurations (t1)
t1_configuration_parameters, t1_configuration_metadata, t1_case_ids = get_test_cases_data(t1_cases_path)

for index in range(len(t1_configuration_metadata)):
    t1_configuration_metadata[index]['location'] = log_test_path
    t1_configuration_parameters[index]['LOCATION'] = log_test_path

t1_configurations = load_configuration_template(t1_configurations_path, t1_configuration_parameters,
                                                t1_configuration_metadata)

local_internal_options = {'logcollector.vcheck_files': '5', 'logcollector.debug': '2', 'windows.debug': 2}

if sys.platform == 'win32':
    prefix = WINDOWS_AGENT_PREFIX

# Configuration
DAEMON_NAME = "wazuh-logcollector"
current_line = 0
file_structure = [
    {
        'folder_path': os.path.join(temp_dir, 'wazuh-testing'),
        'filename': ['test.log'],
        'content': LOG_LINE,
        'size_kib': 10240
    }
]


@pytest.fixture(scope="module")
def get_files_list():
    """Get file list to create from the module."""
    return file_structure


@pytest.mark.parametrize('configuration, metadata', zip(t1_configurations, t1_configuration_metadata), ids=t1_case_ids)
def test_only_future_events(configuration, metadata, set_wazuh_configuration,
                            configure_local_internal_options_module, setup_log_monitor, get_files_list,
                            create_file_structure_module, restart_wazuh_daemon_function):
    '''
    description: Check if the 'only-future-events' option is used properly by the 'wazuh-logcollector' when
                 monitoring a log file. This option allows reading new log content since the logcollector
                 was stopped. For this purpose, the test will create a testing log file and configure a
                 'localfile' section to monitor it. Once the logcollector is started, it will verify that
                 the log file is monitored, add data to it, and verify that the data addition is detected.
                 Then, the test will stop the 'wazuh-logcollector' daemon, and while it is stopped, add more
                 data to the log file. After this, it will check if the addition event has been detected or not
                 (depending on the value of the 'only-future-events' tag). Finally, the test will perform one
                 aditional verification by adding data one more time to the log file and verifying that event
                 indicating the data addition is detected.

    wazuh_min_version: 4.2.0

    tier: 0

    parameters:
        - configuration:
            type: dict
            brief: Get configurations from the module.
        - metadata:
            type: dict
            brief: Get metadata from the module.
        - set_wazuh_configuration:
            type: fixture
            brief: Apply changes to the ossec.conf configuration.
        - configure_local_internal_options_module:
            type: fixture
            brief: Configure the Wazuh local internal options file.
        - setup_log_monitor:
            type: fixture
            brief: Create the log monitor.
        - get_files_list:
            type: fixture
            brief: Get file list to create from the module.
        - create_file_structure_module:
            type: fixture
            brief: Create the specified file tree structure.
        - restart_wazuh_daemon_function:
            type: fixture
            brief: Restart the wazuh service.

    assertions:
        - Verify that the logcollector starts monitoring the log file.
        - Verify that the logcollector detects data addition on a monitored log file.
        - Verify that the logcollector detects the logs messages generated while it stopped
          when it is started, and the 'only-future-events' option is disabled.
        - Verify that the logcollector ignores the logs messages generated while it stopped
          when it is started, and the 'only-future-events' option is enabled.
        - Verify that the log collector continues detecting new logs messages when it is started.

    input_description: A configuration template (test_only_future_events) is contained in an external YAML file
                       (configuration_only_future_events.yaml). That template is combined with two test cases defined
                       in the file cases_only_future_events.yaml.

    expected_output:
        - r'Analyzing file.*'
        - r'Reading syslog message.*'

    tags:
        - logs
    '''
    log_monitor = setup_log_monitor

    global current_line

    # Ensure that the file is being analyzed
    evm.check_analyzing_file(file_monitor=log_monitor, file=log_test_path,
                             error_message=GENERIC_CALLBACK_ERROR_COMMAND_MONITORING, prefix=prefix)

    # Add one KiB of data to log
    current_line = logcollector.add_log_data(log_path=metadata['location'], log_line_message=LOG_LINE,
                                             size_kib=1, line_start=current_line + 1, print_line_num=True)

    message = f"{LOG_LINE}{current_line}"
    evm.check_syslog_messages(file_monitor=log_monitor, message=message,
                              error_message=GENERIC_CALLBACK_ERROR_COMMAND_MONITORING, prefix=prefix,
                              timeout=global_parameters.default_timeout, escape=True)

    control_service('stop', daemon=DAEMON_NAME)

    # Add another KiB of data to log while logcollector is stopped
    first_line = current_line + 1
    current_line = logcollector.add_log_data(log_path=metadata['location'], log_line_message=LOG_LINE,
                                             size_kib=1, line_start=first_line, print_line_num=True)

    control_service('start', daemon=DAEMON_NAME)

    if metadata['only_future_events'] == 'no':
        # Logcollector should detect the first line written while it was stopped
        # Check first line
        message = f"{LOG_LINE}{first_line}"
        evm.check_syslog_messages(file_monitor=log_monitor, message=message,
                                  error_message=GENERIC_CALLBACK_ERROR_COMMAND_MONITORING, prefix=prefix,
                                  timeout=global_parameters.default_timeout, escape=True)
        # Check last line
        message = f"{LOG_LINE}{current_line}"
        evm.check_syslog_messages(file_monitor=log_monitor, message=message,
                                  error_message=GENERIC_CALLBACK_ERROR_COMMAND_MONITORING, prefix=prefix,
                                  timeout=global_parameters.default_timeout, escape=True)
    else:
        # Logcollector should NOT detect the log lines written while it was stopped
        with pytest.raises(TimeoutError):
            # Check first line
            message = f"{LOG_LINE}{first_line}"
            evm.check_syslog_messages(file_monitor=log_monitor, message=message,
                                      error_message=GENERIC_CALLBACK_ERROR_COMMAND_MONITORING, prefix=prefix,
                                      timeout=global_parameters.default_timeout, escape=True)
            # Check last line
            message = f"{LOG_LINE}{current_line}"
            evm.check_syslog_messages(file_monitor=log_monitor, message=message,
                                      error_message=GENERIC_CALLBACK_ERROR_COMMAND_MONITORING, prefix=prefix,
                                      timeout=global_parameters.default_timeout, escape=True)

    # Add another KiB of data to log (additional check)
    current_line = logcollector.add_log_data(log_path=metadata['location'], log_line_message=LOG_LINE,
                                             size_kib=1, line_start=current_line + 1, print_line_num=True)

    # Check last line
    message = f"{LOG_LINE}{current_line}"
    evm.check_syslog_messages(file_monitor=log_monitor, message=message,
                              error_message=GENERIC_CALLBACK_ERROR_COMMAND_MONITORING, prefix=prefix,
                              timeout=global_parameters.default_timeout, escape=True)
