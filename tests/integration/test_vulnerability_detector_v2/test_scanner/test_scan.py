import os
import random

import pytest
import wazuh_testing.db_interface.agent_db as agent_db
import wazuh_testing.modules.vulnerability_detector as vd
from wazuh_testing.modules.vulnerability_detector import event_monitor as evm
from wazuh_testing.tools import configuration as config

# Variables
TEST_DATA_PATH = os.path.join(os.path.dirname(os.path.realpath(__file__)), '..', 'data')
TEST_CASES_PATH = os.path.join(TEST_DATA_PATH, 'test_cases')
TEST_CASES_FILE_PATH = os.path.join(TEST_CASES_PATH, 'case_scan_on_event.yaml')
configuration, metadata, cases_ids = config.get_test_cases_data(TEST_CASES_FILE_PATH)
agent_os = ''

# Marks
pytestmark = [pytest.mark.server]


@pytest.mark.parametrize('metadata', metadata, ids=cases_ids)
def test_scan(metadata, prepare_scan):
    """Checks if the scan is triggered in some scenarios unrelated to specific events.
    """
    pass


@pytest.mark.parametrize('metadata', metadata, ids=cases_ids)
def test_scan_on_firs_start(metadata, prepare_scan):
    """Checks if the scan is triggered and completed correctly when the manager has started for the first time.
    """
    pass


@pytest.mark.parametrize('metadata', metadata, ids=cases_ids)
def test_scan_on_event(metadata, prepare_scan):
    """Checks if the scan is triggered when specific events are generated in the endpoints.
    """

    failures = []
    # Execute the different actions for each vendor and check that the result is the expected
    for vendor in vd.VENDORS:
        # Select an OS
        rand_idx = random.randrange(len(vd.OS_NAME_MAP[vendor]))
        agent_os = vd.OS_NAME_MAP[vendor][rand_idx]
        # agent_os is used by the prepare_scan fixture
        agent_id = prepare_scan

        # Get metadata info
        action = metadata['action']
        package = metadata[vendor]['package']
        version = metadata[vendor]['version']
        hotfix = metadata[vendor]['hotfix']
        old_feed = metadata[vendor]['old_feed']
        updated_feed = metadata[vendor]['updated_feed']

        # Generate event to trigger the scan
        if action == 'install':
            if vendor == 'MSU':
                agent_db.insert_hotfix(agent_id=agent_id, hotfix=hotfix)
            else:
                agent_db.insert_package(agent_id=agent_id, name=package, version=version)
        if action == 'upgrade':
            agent_db.update_package(agent_id=agent_id, package=package, version=version)
        if action == 'remove':
            if vendor == 'MSU':
                agent_db.delete_hotfix(agent_id=agent_id, hotfix=hotfix)
            else:
                agent_db.delete_package(agent_id=agent_id, package=package)
        else:
            vd.update_feed(old_feed, updated_feed)

        # Check the scan has started
        try:
            evm.check_vulnerability_full_scan_start(agent_id=agent_id, timeout=vd.T_10)
        except TimeoutError as e:
            failures.append(f"Error: {e}\nVendor: {vendor}\nOS: {agent_os}")
        # Check the scan has finished
        try:
            evm.check_vulnerability_scan_finished(timeout=vd.T_10)
        except TimeoutError as e:
            failures.append(f"Error: {e}\nVendor: {vendor}\nOS: {agent_os}")


@pytest.mark.parametrize('metadata', metadata, ids=cases_ids)
def test_scan_not_triggered(metadata, prepare_scan):
    """Checks if the scan does not start when certain criteria are met.
    """
    pass
