import os
import random

import pytest
import wazuh_testing.db_interface.agent_db as agent_db
import wazuh_testing.modules.vulnerability_detector as vd
from wazuh_testing.modules.vulnerability_detector import event_monitor as evm
from wazuh_testing.tools import configuration as config

# Variables
TEST_DATA_PATH = os.path.join(os.path.dirname(os.path.realpath(__file__)), '..', 'data')
TEST_CASES_PATH = os.path.join(TEST_DATA_PATH, 'test_cases')
TEST_CASES_FILE_PATH = os.path.join(TEST_CASES_PATH, 'case_scan_on_event.yaml')
configuration, metadata, cases_ids = config.get_test_cases_data(TEST_CASES_FILE_PATH)
agent_os = ''

# Marks
pytestmark = [pytest.mark.server]


@pytest.mark.parametrize('metadata', metadata, ids=cases_ids)
def test_scan_result(metadata, prepare_scan):
    """Checks if the result is correct under specific scenarios.
    """
    # Execute the different actions for each vendor and check that the result is the expected
    for vendor in vd.VENDORS:
        # Select an OS
        rand_idx = random.randrange(len(vd.OS_NAME_MAP[vendor]))
        agent_os = vd.OS_NAME_MAP[vendor][rand_idx]
        # agent_os is used by the prepare_scan fixture
        agent_id = prepare_scan

        # Get metadata info
        action = metadata['action']
        expected_status = metadata['expected_status']
        package = metadata[vendor]['package']
        from_version = metadata[vendor]['from_version']
        to_version = metadata[vendor]['to_version']
        hotfix = metadata[vendor]['hotfix']
        cve_id = metadata[vendor]['cve_id']

        # Generate event to trigger the scan
        if action == 'install':
            if vendor == 'MSU':
                agent_db.insert_hotfix(agent_id=agent_id, hotfix=hotfix)
            else:
                agent_db.insert_package(agent_id=agent_id, name=package, version=to_version)
        if action == 'upgrade':
            agent_db.insert_package(agent_id=agent_id, name=package, version=from_version)
            agent_db.update_package(agent_id=agent_id, package=package, version=to_version)
        else:
            agent_db.delete_package(agent_id=agent_id, package=package)

        # Check that the result is stored
        result_db = vd.check_vulnerability_scan_result_in_database()
        result_indexer = vd.check_vulnerability_scan_result_in_indexer()

        minimum_data = ['cve_id', 'status', 'package_name', 'version']
        expected_data = [cve_id, expected_status, package, to_version]

        # Check that the result has the minimum required data.
        assert minimum_data in list(result_db.keys()), 'The mimimum data is not in the scan result.\n Expected: ' \
                                                       f"{minimum_data}\n Actual: {list(result_db.keys())}"
        assert minimum_data in list(result_indexer.keys()), 'The mimimum data is not in the scan result.\n Expected: ' \
                                                       f"{minimum_data}\n Actual: {list(result_db.keys())}"
        # Check that the result data is correct
        for field in minimum_data:
            assert result_db[field] in expected_data
            assert result_indexer[field] in expected_data


@pytest.mark.parametrize('metadata', metadata, ids=cases_ids)
def test_scan_result_reprocessing(metadata, prepare_scan):
    """Checks if the result reprocessing works as expected.

    Description: When the result is available a Post Scan Action (PSA) is triggered to publish the result in each
    subscriber, if the PSA failed and the subscriber is a priority subscriber then the publish is queued until it can be
    processed again.
    """
    pass
